---
title: 補足プロパティの使用
description: 補足プロパティの使用の概要と Windows での実装方法の詳細
ms.date: 01/10/2017
ms.topic: article
keywords: Windows 10, UWP, WinRT API, インデクサー, 検索
localizationpriority: medium
ms.openlocfilehash: 3103074e7d691897e9a8982a254ba36ee331a2b6
ms.sourcegitcommit: 7b2febddb3e8a17c9ab158abcdd2a59ce126661c
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/31/2020
ms.locfileid: "89175396"
---
# <a name="using-supplemental-properties"></a>補足プロパティの使用  

## <a name="summary"></a>要約  
- 補足プロパティを使用することで、アプリでは、ファイルを変更することなく、プロパティでファイルにタグを付けることができます 
- 計算が難しいプロパティがある場合や、ファイルを変更できない場合に役立ちます 
- 補足プロパティの使用は、Windows プロパティ システムで他のプロパティを使用するのと同じです  

## <a name="introduction"></a>はじめに 
ここ数年の魅力的な新しいアプリの多くでは、ユーザー ファイルで CPU 負荷の高い操作を実行し、作成日などの基本的なもの以外の便利なプロパティをファイルから抽出する必要があります。 これらのアプリでは、イメージのオブジェクト認識、メールのインテント抽出、およびテキスト分析を行ってドキュメントをまとめます。 これは、ほとんどのコンシューマー PC で現在、どの程度強力なコンピューティングを利用できるかに基づきます。   

このメタデータをすぐに検索できるようにすることで、ユーザーの生産性を指数関数的に向上させることができます。 あなたの娘が画像に存在することを認識するだけでも興味深いことですが、彼女がその祖母と一緒にいる画像を検索できることははるかに便利です。 コンピューターの使用のエクスペリエンスが、より個人的で生き生きとしたものに感じられます。 あなたが大切な思い出を見つけられるように、コンピューター内の誰かが手を差し伸べるようなものです。 

何十年もの間、Windows での高速検索のためのソリューションはインデクサーであり、Creators Update では、これらの新しいシナリオをサポートするために更新されています。 アプリでは現在、システムで抽出されるもの以外の追加のプロパティでファイルにタグを付けることができます。 これらのプロパティは最優先として扱われます  

## <a name="windows-properties"></a>Windows プロパティ 
[Windows プロパティ システム](/windows/desktop/properties/windows-properties-system)は、何年もの間、ファイルとのやりとりの重要な部分となっています。 これにより、アプリでは、ファイルで使用される可能性のあるすべてのさまざまなファイル形式または言語の内部構造を理解しなくても、ファイルからプロパティを読み取ることができます。 すべて開発者向けに抽象化されており、必要な作業はリストの要求と昇順または降順の指定だけです。  

プロパティ システムは Windows インデクサーと連動しており、そのスコープ内のファイルからすべてのプロパティを読み取り、格納します。 後で、John Smith によって作成されたものを除く、フォルダー内のすべての .docx のリストを変更日別に並べ替えるようにアプリで求められた場合、インデクサーではそのリストをすぐに返すことができます。  

これらのシステムの連動方法の欠点は、インデクサーでは、ファイルに関する格納されるすべてのプロパティをすぐに使用できるようにする必要があったことです。 厳しい時間的な要件があるため、計算により長い時間がかかる、より興味深いプロパティを認識するには限界がありました。  

しかし、プロパティの使用は簡単であり、アプリでは、データベースの操作と同様、ファイルに関する並べ替えられた一連のプロパティを要求したり、検索エンジンを使用する場合と同じようにクエリを渡すことができます。 インデクサーではクエリを処理し、結果を返します。 これにより、開発者は自分のフィルター (jpg ファイルのみの検索など) とユーザーのクエリ ("bird" で始まるファイル名) を柔軟に組み合わせることができます。 

## <a name="supplemental-properties"></a>補足プロパティ 

補足プロパティは、通常の Windows プロパティと同じように動作しますが、非常に重要な違いが 1 つあります。それは、ファイルがインデクサーに追加されたときに、書き込まれないことです。 補足プロパティは、後からシステム上の別のアプリで追加する必要があります。 これは、オブジェクト認識が完了して 2 分後であるか、数日後である場合があります。 

プロパティが書き込まれたら、システム上の他のプロパティと同じように、検索、フィルター処理、並べ替え、またはグループ化することができます。 さらに、システム上の他の補足プロパティまたはそれ以外のプロパティと結合されたクエリで使用することができます。 これにより、既存のファイル システム コードを書き直さなくても、簡単に補足プロパティと結合する柔軟性が得られます。  

### <a name="example-scenarios"></a>シナリオ例 

補足プロパティに書き込むことができる数千のさまざまなプロパティがありますが、このチュートリアルで常に使用する主なシナリオがいくつかあります。  

#### <a name="tagging-pictures-with-extracted-properties"></a>抽出されたプロパティでの画像へのタグ付け 
これらのアプリでは ML トレーニング済みのモデルを使用し、イメージ内のオブジェクトなど、システムで認識されない機能をイメージから抽出することができます。 その後、イメージで識別されたオブジェクトを取得し、それらを後で検索またはグループ化のためにプロパティ システムに追加することができます。  

#### <a name="tagging-files-with-an-app-specific-id"></a>アプリ固有の ID でのファイルへのタグ付け 
多くのファイル同期アプリでは、サーバーとさまざまなクライアント デバイス間での移動の際に、独自の一意の ID を使用してファイルを追跡します。 同期クライアントでは、ファイルに影響を与えることなく、この ID をプロパティ システムに書き込むことができます。 この ID は現在、高速アクセスのために後でアプリで使用でき、同期プロバイダーとの通信時にシステム上の他のアプリで読み取ることができます。 

補足プロパティを使用するためのオプションは他にもたくさんありますが、これらの両方が良い例となります。これは、高速参照または検索を必要とし、システムで認識されない情報であり、ファイル自体に追加できないためです。  

### <a name="using-supplemental-properties"></a>補足プロパティの使用 
補足プロパティの使用は、ファイル システムへの通常のプロパティの書き込みと同じです。 StorageFile とプロパティの使用に慣れている場合は、これを省略できます。 それ以外の場合は、単一のプロパティをファイルに書き込んでから、後で同じプロパティを読み取る簡単なサンプルを見てみましょう。  

### <a name="writing-supplemental-properties"></a>補足プロパティの書き込み  
サンプルでは、わかりやすくするために、検出される最初のファイルのみを変更しますが、通常はアプリで検出されたすべてのファイルにプロパティが追加されます。  

```csharp
// Only indexed jpg files are going to be used 
QueryOptions option = new QueryOptions(CommonFileQuery.DefaultQuery, new string[] { ".jpg" }); 
option.IndexerOption = IndexerOption.OnlyUseIndexer; 
// Typically an app would loop over all the files in the library, updating them all with the new 
// value. To make the sample easier to understand however, this app is only going to update the  
// first file it finds 
var query = KnownFolders.PicturesLibrary.CreateFileQueryWithOptions(option); 
StorageFile file = (await query.GetFilesAsync()).FirstOrDefault(); 
if (file == null) 
{ 
    log("No jpg file found in the library. Stopping"); 
    return; 
} 
log("Found file: " + file.Path); 
// Selecting the property to modify and writing it out 
List<KeyValuePair<string, object>> props = new List<KeyValuePair<string, object>>();             
props.Add(new KeyValuePair<string, object>("System.Supplemental.ResourceId", fileId)); 
await file.Properties.SavePropertiesAsync(props); 
```

プロパティを書き込む前に、場所にインデックスが付けられているかどうかの重要な確認があります。 このサンプルでは、インデックス付きの場所のみにフィルター処理するクエリ オプションを使用します。 これが実行できない場合は、親フォルダー (file.GetParentAsync().GetIndexedStateAsync()) のインデックス状態を確認できます。 いずれの場合も、得られる結果は同じです 

### <a name="reading-supplemental-properties"></a>補足プロパティの読み取り 
ここでも、補足プロパティの読み取りは、他のファイル システム プロパティの読み取りと同じです。 このサンプルでは、アプリで、StorageFile が既に存在するファイルから 1 つのプロパティのみを読み取りますが、同時に他のプロパティを読み取ることもできます。  

```csharp
// An object to hold the result from the indexer, and a string to store  
// the value in once we have confirmed it is valid. 
object uncheckedResourceId; 
string resourceId = ""; 
// Fetching the key value pair from the indexer 
IDictionary<string,object> returnedProps =  
    await file.Properties.RetrievePropertiesAsync(new string[] { "System.Supplemental.ResourceId" });             
if (returnedProps.TryGetValue("System.Supplemental.ResourceId", out uncheckedResourceId)) 
{ 
    if (uncheckedResourceId != null && !String.IsNullOrEmpty(uncheckedResourceId.ToString())) 
    { 
        resourceId = uncheckedResourceId.ToString(); 
    } 
} 
```
プロパティ システムから返される値が期待どおりのものであることの確認があります。 可能性は低くても、値はアプリで書き込まれた後、クリアされている場合があります。 これについては以下で詳しく説明します。  

### <a name="implementation-notes"></a>実装に関する注意事項 
補足プロパティの設計時に行われた微妙な選択がいくつかあります。 実装に役立つように、機能に関するエンジニアリング設計仕様から以下のセクションがコピーされました。 これにより、機能の設計方法と、制限事項がいくつか存在する理由を簡単に確認することができます。 

### <a name="supplemental-properties-available"></a>使用可能な補足プロパティ 
アプリを最初に使用するときに利用可能なプロパティは次の 2 つのみです: System.Supplemental.ResourceId と System.Supplemental.AlbumID。 さらに必要な場合は、追加できます。 アルバム ID は複数値文字列であり、これをさまざまなアプリケーションで使用できます。ResourceId は、クラウド同期プロバイダーの一意の ID として使用されます。 

#### <a name="file-system-support"></a>ファイル システムのサポート 
FAT 形式のリムーバブル メディアは重要なシナリオであるため、補足プロパティでは FAT および NTFS ドライブがサポートされます。 これにより、補足プロパティを、そのデバイスの種類に関係なく、すべてのユーザーが確実に利用できるようになります。   

### <a name="non-indexed-locations"></a>インデックスのない場所  
デスクトップ上には、インデックスが付いていない多くのフォルダーがあります。 このような場合、アプリでは引き続き、補足プロパティにアクセスできる必要がある場合があります。 しかし、インデックス付きの場所の外部で補足プロパティを使用することはできません。 このトレードオフは、次のいくつかの理由によるものです。  

- 既定では、すべてのライブラリおよびクラウド ストレージの場所にインデックスが付けられます。   
  これらは、UWP アプリで主に使用される場所です。 インデックスが付いていない場所 (システムまたはネットワーク ドライブ) は他にもありますが、ユーザー データの格納ではそれほど使用されません。 

- WinRT API サーフェスの設計では、インデクサーがほとんどの場合、使用可能であることが前提となります。  
  したがって、インデクサーは、アプリの対象となるほとんどの場所で既に使用可能です。 ユーザーがインデックスのない場所にデータを格納していることがわかった場合、最も簡単な解決策は、その場所をインデックスに追加することです。 そうすると、補足プロパティが機能し、列挙がより高速になり、アプリでは場所の変更追跡が可能になります。

### <a name="reading-or-writing-supplemental-properties-from-a-file-in-a-non-indexed-location"></a>インデックスのない場所にあるファイルからの補足プロパティの読み取りまたは書き込み 
アプリで、現在インデックスが付いていない場所に補足プロパティの書き込みが試行された場合、API 呼び出しで例外がスローされます。 これは、誰かが .docx ファイル (Invalid Args) の System.Music.AlbumArtist を更新しようとしたときにスローされるのと同じ例外です。  
 
### <a name="change-notifications"></a>変更通知:  
UWP 変更通知と変更追跡は、標準プロパティの場合と同じように、補足プロパティで引き続き動作します。 これにより、データを提供しているアプリでは、そのアプリのいずれかで発生したすべての変更を追跡できるようになります 
  
### <a name="invalidating-properties"></a>プロパティの無効化:  
ファイル上の補足プロパティは、システム上のファイルが変更または移動されるたびに、古くなる可能性があります。 データをプッシュするアプリには、データが有効か、またはデータを更新し、システムで単にツールをアプリに提供して自身で把握できるようにする必要があるかどうかに関する情報があります。  
 
ファイルが変更されても、移動や名前変更が行われない場合、ファイル上の補足プロパティはすべてそのままです。 アプリでは、既存の API サーフェスを介して変更通知を登録し、必要に応じてプロパティを更新できるようになります。 
 
ファイルが移動された場合、プロパティは無効になります。 アプリでは、操作がどの程度正確に行われるかに応じて、削除、作成、名前変更、移動の変更通知を受け取ることになります。 アプリでは、変更通知を受け取ると、ファイルを検査し、必要に応じて、ファイルの補足プロパティを更新できます。 
 
### <a name="indexer-rebuilds"></a>インデクサーの再構築  
場合によっては、プロパティ スキーマが変わる可能性がある、ユーザーが EDP を有効にする可能性がある、あるいは単にデータベース ファイルが破損している可能性があるなどの多くの理由のいずれかにより、システム インデックスを再構築する必要があります。 このような場合、補足プロパティは保持されません。 インデックスが再構築されるときに、補足プロパティの保持を試みる作業を行うことを検討しましたが、主な妨げとなるものがいくつかありました。  

### <a name="protecting-the-data"></a>データの保護 
ディスク エラーまたは不正ソフトウェアによって、データベース ファイルが破損した場合、そのファイルに格納されたデータを保護できなくなります。 システム上のどこか別の場所、または残りのデータベースから分離された何らかの形で格納する必要があります。 

インデックスが破損する可能性を低くするために既に多くの作業を行っているため、いずれにせよ、このケースの発生率は低下します。  
再構築中でのファイルとそのメタデータ間のマッピングの維持 

インデックスでは、再構築時にデータを保護することができても、インデックスの再構築中にファイルが変更されたかどうかを把握することはできません。 インデックスでファイルから保護されるデータは、そのファイルが変更または移動された場合に有効でなくなる可能性があります。  
動作 

インデクサーが再構築された場合、補足データはすべて失われます。 再構築時に失われたデータをインデクサーに戻すのはアプリの担当となります。 これにより、アプリに余分な負担がかかりますが、すべてのデータのマスター状態が常に保持されるため、合理的と考えられます。  

### <a name="recovering"></a>回復 
インデックスが再構築されていることがアプリで認識されたら、適宜、補足プロパティを更新することはアプリの担当となります。  
### <a name="privacy"></a>プライバシー 
ファイルに書き込まれる可能性のあるプロパティの中には、ユーザーが他のアプリケーションと共有したくないものがあります。 アプリでは、プロパティに書き込まれる情報をいずれかのアプリケーションに対してプライベートにするか、他のごく一部のアプリケーションとのみ共有するか、システム上のすべてのアプリに対してパブリックにするかを示すことができる必要があります。  

これは、機能の一部の早期導入者にとっては興味深い機能である可能性はありますが、それでもパブリック プロパティを取得することは設計に多くの価値が付加されるものと考えられます。 したがって、これはあると便利なものと見なされます。必要に応じて、このような価値を隠すためのサポートなしで機能の構築を続行する必要があります。 後でこれを加えると、さらにシナリオを開くことになるため、設計時に考慮することが重要になります。  

## <a name="conclusions"></a>結論 
これで終わりです。補足プロパティは、より多くのファイル プロパティをシステムに格納するための簡単な方法です。 それらの使用はもちろん省略可能ですが、データを迅速に並べ替えて検索できない他のアプリより、自分のアプリを優れたものにすることができます。 

アプリでぜひ、これらのプロパティの使用を開始してください。 方法についてご不明な点がある場合は、ヘッダーを使用し、以下のコメントでお知らせください