---
title: 非同期プログラミング (DirectX と C++)
description: このトピックでは、DirectX で非同期プログラミングやスレッディングを使う際のさまざまな考慮事項について取り上げます。
ms.assetid: 17613cd3-1d9d-8d2f-1b8d-9f8d31faaa6b
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10、UWP、ゲーム、非同期プログラミング、DirectX
ms.localizationpriority: medium
ms.openlocfilehash: e5a8eb1ee9cd6a7b5a00eaf13bf04d8956df42c5
ms.sourcegitcommit: 7b2febddb3e8a17c9ab158abcdd2a59ce126661c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/31/2020
ms.locfileid: "89172066"
---
# <a name="asynchronous-programming-directx-and-c"></a>非同期プログラミング (DirectX と C++)



このトピックでは、DirectX で非同期プログラミングやスレッディングを使う際のさまざまな考慮事項について取り上げます。

## <a name="async-programming-and-directx"></a>非同期プログラミングと DirectX


DirectX の学習経験や使用経験にかかわらず、グラフィックス処理パイプラインはすべてシングル スレッドで実行することをお勧めします。 ゲーム内のシーンには、排他的アクセスを必要とするリソースがいたるところに使われています。ビットマップやシェーダーといった各種アセットはその代表的な例です。 しかも、これらのリソースへのアクセスは、並列スレッド間ですべて同期させる必要があります。 レンダリングは、複数のスレッドで並列化することの難しい処理です。

しかし、ゲームの構造に十分な複合性がある場合や、ゲームのパフォーマンスを強化する必要性がある場合、レンダリング パイプラインに直接関係しない一部のコンポーネントを非同期プログラミングによって並列化することは可能です。 最近のハードウェアは、マルチ コアとハイパースレッディングに対応した CPU を搭載しているので、ぜひそれを活かしましょう。 その確実な方法は、ゲームのコンポーネントのうち、Direct3D のデバイス コンテキストに直接アクセスする必要のないコンポーネントに非同期プログラミングを適用することです。たとえば、次のようなコンポーネントが該当します。

-   ファイル I/O
-   物理
-   AI
-   networking
-   audio
-   controls
-   XAML ベースの UI コンポーネント

こうしたコンポーネントについては、複数の同時実行スレッド上で処理することができます。 ファイル I/O (特にアセットの読み込み) を非同期で行うと、数メガバイトや数百メガバイトのアセットを読み込んだりストリーミングしたりしている間も、ゲームやアプリのインターフェイスを操作できるようになるため、マルチ スレッド化には非常に大きな意義があります。 これらのスレッドは、[並列パターン ライブラリ](/cpp/parallel/concrt/parallel-patterns-library-ppl) と **task** パターン (PPLTasks.h に定義されている **concurrency** 名前空間) を使って作成、管理するのが最も簡単です。 [並列パターン ライブラリ](/cpp/parallel/concrt/parallel-patterns-library-ppl) は、マルチ コアとハイパースレッディングに対応した CPU の利点をダイレクトに引き出し、体感的な読み込み時間から、CPU 計算やネットワーク処理の集中に伴う滞りや遅延にいたるまで、さまざまな側面を向上させます。

> **メモ**   ユニバーサル Windows プラットフォーム (UWP) アプリでは、ユーザーインターフェイスはシングルスレッドアパートメント (STA) で完全に実行されます。 DirectX ゲーム用の UI を [XAML の相互運用機能](directx-and-xaml-interop.md) を使って作成する場合、そのコントロールには、STA を使ってのみアクセスできます。

 

## <a name="multithreading-with-direct3d-devices"></a>Direct3D デバイスでのマルチスレッド化


デバイスコンテキストのマルチスレッドは、Direct3D の機能レベル 11 0 以上をサポートするグラフィックスデバイスでのみ使用でき \_ ます。 しかし、ゲーム専用機など、数多くのプラットフォームに搭載されている強力な GPU は最大限に活用したいものです。 たとえば、単純なケースでは、ヘッドアップ ディスプレイ (HUD) オーバーレイのレンダリングを 3D シーンのレンダリングとプロジェクションから切り離し、2 つのコンポーネントに独立した並列パイプラインを割り当てることができます。 どちらのスレッドも、同じ [**ID3D11DeviceContext**](/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext) を使ってリソース オブジェクト (テクスチャ、メッシュ、シェーダーなど、各種アセット) を作成、管理する必要がありますが、ID3D11DeviceContext はシングル スレッドであり、安全にアクセスするには何らかの同期機構 (クリティカル セクションなど) を実装する必要があります。 また、異なるスレッドのデバイス コンテキストに対し、(遅延レンダリング用の) 別々のコマンド リストを作成している間、これらのコマンド リストを同じ **ID3D11DeviceContext** インスタンスで同時に再生することはできません。

現在では、スレッド セーフな [**ID3D11Device**](/windows/desktop/api/d3d11/nn-d3d11-id3d11device) を使ってリソース オブジェクトを作成することもできるようになりました。 このような状況であれば、**ID3D11DeviceContext** は使わず、常に [**ID3D11Device**](/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext) を使えばよいのではないでしょうか。 現時点では、一部のグラフィックス インターフェイスで、ドライバーがマルチスレッドをサポートしていない可能性があります。 デバイスに対して問い合わせを行い、マルチスレッドをサポートしているかどうかを調べることもできますが、幅広いユーザーを対象とするために、あえてシングル スレッドの **ID3D11DeviceContext** を使って、リソース オブジェクトを管理する場合があります。 もっとも、グラフィックス デバイス ドライバーがマルチスレッドやコマンド リストをサポートしていない場合、Direct3D 11 は、デバイス コンテキストへの同期アクセスを内部的に処理することを試み、コマンド リストがサポートされていなかった場合は、ソフトウェアによって実装された同等の機能を提供します。 結果として、プラットフォームのグラフィックス インターフェイスについて、デバイス コンテキストへのマルチスレッド アクセスをドライバーがサポートしていない場合でもきちんと動作するマルチスレッド対応のコードを作成することが可能です。

開発しているアプリが、コマンド リストの処理用とフレームの表示用に別々のスレッドをサポートする場合、GPU はアクティブにしておきましょう。体感的な引っかかりや遅延を生じることなく適切なタイミングでフレームを表示すると共に、コマンド リストを処理することができます。 この場合、スレッドごとに個別の [**である id3d11devicecontext**](/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext) を使用し、リソース (テクスチャなど) を共有するには、D3D11 リソースのその他の共有フラグを使用してリソースを作成し \_ \_ \_ ます。 このシナリオでは、処理用のスレッドで [**ID3D11DeviceContext::Flush**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) を呼び出し、コマンド リストの実行を完了してから、表示用のスレッドで、リソース オブジェクトの処理結果を表示する必要があります。

## <a name="deferred-rendering"></a>遅延レンダリング


遅延レンダリングは、グラフィックス コマンドを後から再生できるようにコマンド リストに記録するもので、一方のスレッドでレンダリングを行いながら、別のスレッドで、レンダリングに使うコマンドを記録するしくみになっています。 必要なコマンドがすべて揃った後、最終的な表示オブジェクト (フレーム バッファー、テクスチャなどのグラフィックス出力) を生成したスレッド上で、それらのコマンドを実行することができます。

遅延コンテキストは、(イミディエイト コンテキストを作成する) [**D3D11CreateDevice**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice) や [**D3D11CreateDeviceAndSwapChain**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain) ではなく、[**ID3D11Device::CreateDeferredContext**](/windows/desktop/api/d3d11/nf-d3d11-id3d11device-createdeferredcontext) を使って作成します。 詳しくは、「[イミディエイト レンダリングおよびディファード レンダリング](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render)」をご覧ください。

## <a name="related-topics"></a>関連トピック


* [Direct3D 11 でのマルチスレッドの概要](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-intro)

 

 