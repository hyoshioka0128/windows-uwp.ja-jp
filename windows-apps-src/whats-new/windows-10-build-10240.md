---
description: Windows 10 ビルド 10240 と開発者ツールの更新プログラムでは、引き続きユニバーサル Windows プラットフォームによって強化されたツール、機能、およびエクスペリエンスを提供しています。
title: Windows 10 ビルド 10240 の新着情報 - 2015 年 7 月
keywords: Windows 10, 1507, 10240
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: 282026436355c1bcaab504d2818c2a30ff09e20d
ms.sourcegitcommit: a3bbd3dd13be5d2f8a2793717adf4276840ee17d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2020
ms.locfileid: "93029915"
---
# <a name="whats-new-in-windows-10-for-developers-build-10240"></a>Windows 10 ビルド 10240 の開発者向け新着情報

Windows 10 ビルド 10240 と更新された SDK では、優れたユニバーサル Windows プラットフォーム アプリを作るためツール、機能、エクスペリエンスを利用できます。 Windows 10 への[ツールと SDK のインストール](https://developer.microsoft.com/windows/downloads#_blank)が完了したら、[新しいユニバーサル Windows アプリを作成](../get-started/create-uwp-apps.md)したり、[Windows の既存のアプリ コード](../porting/index.md)がどのように使えるかを試したりすることができます。

以下では、Windows 10 ビルド 10240 (Windows 10 バージョン 1507 とも呼ばれます) の新機能をそれぞれ見ていきます。

## <a name="adaptive-layouts"></a>アダプティブ レイアウト

機能 | 説明
 :---- | ----:
複数のビューによるコンテンツのカスタマイズ | XAML で、同じコード ファイルを共有する複数のカスタム ビュー (.xaml ファイル) を定義できるようになりました。 特定のデバイス ファミリや特定のシナリオ向けにカスタマイズしたさまざまなビューを従来よりも簡単に作成、管理することができます。 状況によってまったく異なる UI コンテンツやレイアウト、ナビゲーション モデルをアプリで使い分ける場合は、複数のビューを作成しましょう。 たとえば、モバイル アプリには片手での操作に最適なナビゲーションと[ピボット](/uwp/api/Windows.UI.Xaml.Controls.Pivot)を、デスクトップ アプリにはマウスでの操作に最適なナビゲーション メニューと [SplitView](/uwp/api/Windows.UI.Xaml.Controls.SplitView) を組み合わせることができます。
StateTriggers | 新しい [VisualState.StateTriggers](/uwp/api/windows.ui.xaml.visualstate.statetriggers) 機能を使うと、ウィンドウの高さや幅、カスタム トリガーを基準とし、条件に従ってプロパティを設定することができます。 従来は、ウィンドウの [SizeChanged](/uwp/api/windows.ui.xaml.window.sizechanged) イベントをコード内で処理し、[VisualStateManager.GotoState](/uwp/api/windows.ui.xaml.visualstatemanager.gotostate) を呼び出す必要がありました。
Setter | [VisualStateManager](/uwp/api/windows.ui.xaml.visualstatemanager) でプロパティの変更を定義する際に使うマークアップが、新しい [VisualState.Setters](/uwp/api/windows.ui.xaml.visualstate.setters) 構文によって単純化されています。 [StackPanel](/uwp/api/windows.ui.xaml.controls.stackpanel) の向きを横から縦にするなど、プロパティの変更を適用するとき、従来であれば、ストーリーボードを使ってアニメーションを作成する必要がありました。 ユニバーサル Windows アプリでは、次のようにシンプル化された Setter 構文を使うことができます: <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>XAML の機能

機能 | 説明
 :---- | :----
データ バインディングのコンパイル (x:Bind) | ユニバーサル Windows アプリで、コンパイラ ベースのバインディングを行うことができるようになりました。この機構を有効にするには、x:Bind プロパティを使います。 コンパイルの時点で厳密に型指定されたうえで処理されることから、コンパイラ ベースのバインディングには、高速化できることに加え、バインディングの型が一致しないときにはコンパイル時にエラーを検出できるという 2 つの利点があります。 また、バインディングはコンパイル済みのアプリ コードに変換されるため、Visual Studio からコードをステップ実行してデバッグすることにより、バインディングの問題を詳しく診断することができます。 また、次のように、x:Bind を使ってメソッドにバインドすることもできます。<textblock text="{x:Bind Customer.Address.ToString()}" /> 一般的なバインディングのシナリオでは、Binding の代わりに x:Bind を使うことができ、それによってパフォーマンスが向上し、メンテナンスもしやすくなります。
宣言型の段階的レンダリングによるリストの表示 (x:Phase) | ユニバーサル Windows アプリで新しい x:Phase 属性を使うと、コードからではなく XAML を使ってリストを段階的にレンダリングすることができます。 複雑な項目がいくつも連なったようなリストをパンすると、項目のレンダリングがパンの速度に追い付かず、アプリのユーザーにネガティブな印象を与える可能性があります。 高速にパン操作を実行しなければならない状況では、リストの要素ごとにレンダリングの優先順位を指定して、特に重要な部分だけをレンダリングすることができます。 よりスムーズなパンが可能となり、アプリの操作感が向上します。 <br /><br /> Windows 8.1 でも、必要なコードを [ContainerContentChanging](/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) イベント処理に記述すれば、リスト項目を段階的にレンダリングすることはできます。 UWP アプリでは、x:Phase 属性を使って宣言的にレンダリングを段階化することが可能です。 バインディングのコンパイルを行う x:Bind と組み合わせれば、バインド対象の要素ごとにレンダリングの優先順位をデータ テンプレートで簡単に指定することができます。 リスト項目をレンダリングする処理には、パン操作の実行中、段階に応じてタイム スライスが割り当てられ、それによって項目を少しずつ描画することが可能となります。
UI 要素の遅延読み込み (x:deferLoadstrategy) | ユニバーサル Windows アプリでは、新しい x:deferLoadstrategy ディレクティブで遅延読み込みするインターフェイスの部分を指定して、起動パフォーマンスを改善したり、アプリのメモリ使用量を抑えることができます。 たとえば、間違ったデータが入力された時だけ表示されるデータ検証要素がアプリの UI にある場合、必要な時までその要素の読み込みを遅らせることができます。 ページが読み込まれた時にエレメント オブジェクトは作成されず、データ エラーがある時のみ作成されるため、ページのビジュアル ツリーに追加する必要があります。
SplitView | 一時的に必要となるコンテンツには、新しい [SplitView](/uwp/api/windows.ui.xaml.controls.splitview) コントロールを使うことで、表示と非表示を簡単に切り替えることができます。 一般的な使い方として、トップレベルのナビゲーションが挙げられます。たとえば、"ハンバーガーのメニュー" で、ナビゲーション コンテンツを非表示にしておき、ユーザーの操作の結果、必要であればメニューをフェード インさせることができます。
RelativePanel | [RelativePanel](/uwp/api/windows.ui.xaml.controls.relativepanel) は、オブジェクトの位置を他のオブジェクト (または親パネル) との位置関係で指定して配置できる新しいレイアウト パネルです。 たとえば、テキストは常にパネルの左側に配置し、ボタンは必ずそのテキストの下に来るように指定することができます。 ユーザー インターフェイスを作成するとき、はっきりとした線に沿って位置決めできるようなパターンであれば、[StackPanel](/uwp/api/windows.ui.xaml.controls.stackpanel) や [Grid](/uwp/api/windows.ui.xaml.controls.grid) を使いますが、そうしたパターンがないときに ReleativePanel を使います。
CalendarView | [CalendarView](/uwp/api/windows.ui.xaml.controls.calendarview) は、カスタマイズ可能な月単位のビューで日付や日付範囲を簡単に表示、選択できるコントロールです。 最小日付、最大日付、ブラックアウト日などの機能を使って、選択できる日付を制限することができます。 特定の日におけるスケジュールのおおよその "埋まり具合" を示すカスタムの予約状況バーを設定することもできます。
CalendarDatePicker | [CalendarDatePicker](/uwp/api/windows.ui.xaml.controls.calendardatepicker) は、カレンダーの曜日や埋まり具合などのコンテキスト情報が必要となる CalendarView から単一の日付を選ぶ用途に最適なドロップダウン コントロールです。 [DatePicker](/uwp/api/windows.ui.xaml.controls.datepicker) コントロールと似ていますが、DatePicker は、誕生日など既知の日付が選びやすいように配慮されています。
MediaTransportControls | [MediaElement](/uwp/api/windows.ui.xaml.controls.mediaelement) のトランスポート コントロールは、新しい [MediaTransportControls](/uwp/api/windows.ui.xaml.controls.mediatransportcontrols) クラスを使って簡単にカスタマイズすることができます。 Windows 8.1 でも、MediaElement の組み込みのトランスポート コントロールを有効にするか、MediaElement のメソッドを呼び出すトランスポート コントロールを独自に作成することはできます。 今後は、MediaTransportControls の組み込み機能を使いながら、アプリに合わせて外観を簡単にカスタマイズすることができます。
プロパティ変更通知 | ユニバーサル Windows アプリでは、DependencyObjects でプロパティの変化をリッスンすることができ、対応する変更イベントを持たないプロパティの変化まで検出することができます。 通知はイベントと同様に動作しますが、実際にはコールバックとして公開されます。 コールバックは、イベント ハンドラーと同じように sender 引数を受け取りますが、イベント引数は受け取りません。 代わりに、どのプロパティかを示すためにプロパティ識別子のみが渡されます。 アプリでは、この情報を使って、いくつかのプロパティ通知に対応した単一のハンドラーを定義できます。 詳しくは、[RegisterPropertyChangedCallback](/uwp/api/windows.ui.xaml.dependencyobject.registerpropertychangedcallback) および [UnregisterPropertyChangedCallback](/uwp/api/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback) をご覧ください。
マップ | [MapControl](/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) クラスが更新されて、航空写真の 3D 表示と道路地図表示が提供されるようになりました。 これらの新機能と以前のマッピング機能をユニバーサル Windows アプリで使用できるようになりました。 マッピングをアプリに追加するには、次の API を使用します。[Windows.UI.Xaml.Controls.Maps](/uwp/api/windows.ui.xaml.controls.maps) および [Windows.Services.Maps](/uwp/api/windows.services.maps)。 現在のユニバーサル Windows アプリでこれらの API を使うには、最初に [Bing Maps Developer Center](https://www.bingmapsportal.com/) からキーを取得します。 詳しくは、[マップ アプリを認証する方法](/previous-versions/windows/apps/dn741528(v=win.10))に関するページをご覧ください。 Also new for Windows 10, PC and phone users can download offline maps from the Settings app. オフライン マップが使用できる場合、[MapControl](/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) は、インターネットにアクセスできないときにオフライン マップを使用します。
入力ボタンのマッピング | [Windows.UI.Xaml.Input.KeyEventArgs](/uwp/api/windows.ui.xaml.input.keyroutedeventargs) クラスには、新しい [OriginalKey](/uwp/api/windows.ui.xaml.input.keyroutedeventargs.originalkey) プロパティがあり、これを、[Windows.System.VirtualKey](/uwp/api/windows.system.virtualkey) の対応する更新と共に使うと、キーボードの入力イベントに関連付けられている、マップされていない元の入力ボタンを取得できます。
手描き入力 | [InkCanvas](/uwp/api/windows.ui.xaml.controls.inkcanvas) コントロールと、基になる [InkPresenter](/uwp/api/windows.ui.input.inking.inkpresenter) クラスにより、C++、C#、または Visual Basic で Windows ランタイム アプリに堅牢な手描き入力機能をさらに簡単に使用できるようになりました。 [InkCanvas](/uwp/api/windows.ui.xaml.controls.inkcanvas) コントロールは、インク ストロークの描画とレンダリングのためのオーバーレイ領域を定義します。 このコントロールの機能 (入力、処理、レンダリング) は、[InkPresenter](/uwp/api/windows.ui.input.inking.inkpresenter)、[InkStroke](/uwp/api/windows.ui.input.inking.inkstroke)、[InkRecognizers](/uwp/api/windows.ui.input.inking.inkrecognizer)、[InkSynchronizer](/uwp/api/windows.ui.input.inking.inksynchronizer) の各クラスから提供されます。 **重要:** これらのクラスは、JavaScript を使用した Windows アプリではサポートされていません。


## <a name="updated-xaml-features"></a>更新された XAML の機能

機能 | 説明
 :---- | :----
CommandBar と AppBar の更新 | 異なるデバイス ファミリ間で一貫性のある API と動作、ユーザー エクスペリエンスを UWP アプリで実現できるように、[CommandBar](/uwp/api/windows.ui.xaml.controls.commandbar) コントロールと [AppBar](/uwp/api/windows.ui.xaml.controls.appbar) コントロールが更新されています。 <br /><br />ユニバーサル Windows アプリの CommandBar コントロールは、AppBar のスーパーセットとなる機能を備え、アプリにおける使い方の幅も広がっています。 Windows 10 では、新しいユニバーサル Windows アプリにはすべて CommandBar を使うことをお勧めします。 Windows 8.1 の CommandBar では、使用できるコントロールが、[ICommandBarElement](/uwp/api/windows.ui.xaml.controls.icommandbarelement) を実装するコントロールに限られていました ([AppBarButton](/uwp/api/windows.ui.xaml.controls.appbarbutton) など)。 今後は、ユニバーサル Windows アプリの CommandBar に AppBarButtons だけでなくカスタム コンテンツを追加することができます。 <br /><br />AppBar が使われている Windows 8.1 アプリをユニバーサル Windows プラットフォームに移行しやすいよう、AppBar コントロールが更新されています。 AppBar は、全画面表示アプリで画面端のジェスチャを使って呼び出す使い方を想定して設計されました。 Window 10 でアプリにウィンドウが存在するケースや、画面端のジェスチャがないなどの問題がこの変更で解消されます。 <br /><br />これまで Windows Phone に限定されていた [AppBar.ClosedDisplayMode](/uwp/api/windows.ui.xaml.controls.appbar.closeddisplaymode) の Hidden モードが今後はすべてのデバイス ファミリでサポートされ、さまざまなレベルのヒントをコマンドで使い分けることができます。 Windows 8.1 アプリをユニバーサル Windows アプリにアップグレードすると、プラットフォームに備わっている画面端のジェスチャ機能を利用することができなくなります。一貫性を確保するために、既定では AppBar に最小限のヒントが表示されます。
GridView の更新 | Windows 10 より前のバージョンでは、GridView レイアウトの既定の方向が、Windows では水平方向に、Windows Phone では垂直方向になっていました。 UWP アプリの GridView では、一貫した初期設定を確保するために、すべてのデバイス ファミリに垂直方向のレイアウトが既定で使用されます。
AreStickyGroupHeadersEnabled プロパティ | グループ化されたデータを表示している [ListView](/uwp/api/windows.ui.xaml.controls.listview) または [GridView](/uwp/api/windows.ui.xaml.controls.gridview) でリストがスクロールされたとき、グループ ヘッダーが常時表示されるようになりました。 ユーザーが閲覧しているデータのコンテキストはヘッダーに表示されるので、大きなデータセットではこのことが重要となります。 ただし、各グループの項目数がわずかであれば、それらの項目と一緒にヘッダーを画面外にスクロールした方がよい場合もあります。 この動作は、[ItemsStackPanel](/uwp/api/windows.ui.xaml.controls.itemsstackpanel) と [ItemsWrapGrid](/uwp/api/windows.ui.xaml.controls.itemswrapgrid) の AreStickyGroupHeadersEnabled プロパティを設定することによって制御できます。
GroupHeaderContainerFromItemContainer メソッド | グループ化されたデータを [ItemsControl](/uwp/api/windows.ui.xaml.controls.itemscontrol) で表示するときに、[GroupHeaderContainerFromItemContainer](/uwp/api/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer) メソッドを呼び出すことで、そのグループの親ヘッダーの参照を取得することができます。 たとえば、グループ内の最後の項目がユーザーによって削除されるときに、そのグループ ヘッダーの参照を取得して、項目とグループ ヘッダーの両方をまとめて削除することができます。
ChoosingGroupHeaderContainer イベント | [ListViewBase](/uwp/api/windows.ui.xaml.controls.listviewbase) の新しい [ChoosingGroupHeaderContainer](/uwp/api/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer) イベントを使うと、ListView または GridView のグループ ヘッダーに関する状態を設定することができます。 たとえば、このイベントの処理でグループ ヘッダーの [AutomationProperties.Nameproperty](/uwp/api/windows.ui.xaml.automation.automationproperties.nameproperty) を設定することによって、支援技術のグループを表すことができます。
ChoosingItemContainer イベント | ListViewBase に新しい [ChoosingItemContainer](/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) イベントが追加され、[ListView](/uwp/api/windows.ui.xaml.controls.listview) または [GridView](/uwp/api/windows.ui.xaml.controls.gridview) における UI の仮想化を、従来よりも自由に制御できるようになりました。 [ContainerContentChanging](/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) イベントと一緒に使うことで、リサイクルするコンテナーのキューを独自に管理し、そこから必要に応じて描画することができます。 たとえば、フィルタリングによってデータ ソースがリセットされた場合、作成済みの一連のビジュアル (ItemContainers) とそのデータをすばやく突き合わせてパフォーマンスを最大限に引き出すことができます。
リストのスクロールの仮想化 |XAML の [ListView](/uwp/api/windows.ui.xaml.controls.listview) コントロールと [GridView](/uwp/api/windows.ui.xaml.controls.gridview) コントロールに用意されている新しい [ListViewBase.ChooseingItemContainer](/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) イベントは、データ コレクションに変更が発生した場合のコントロールのパフォーマンスを改善します。 リストを完全にリセットして開始アニメーションを再生するのではなく、現在表示されている項目をフォーカスや選択状態も含めて維持します。ビューポート内の新しい項目と削除された項目は、アニメーション化されてスムーズに表示されたり消えたりします。 コンテナーが破棄されないデータ コレクション内の変更の後、アプリは "古い" 項目を以前のコンテナーとすばやく比較し、コンテナー ライフサイクルをオーバーライドするメソッドの以降の処理をスキップできます。 "新しい" 項目のみが処理され、リサイクルされたコンテナーまたは新しいコンテナーに関連付けられます。
SelectRange メソッドと SelectedRanges プロパティ | ユニバーサル Windows アプリで、[ListView](/uwp/api/windows.ui.xaml.controls.listview) コントロールと [GridView](/uwp/api/windows.ui.xaml.controls.gridview) コントロールを使って、項目オブジェクトの参照ではなく、項目インデックスの範囲の観点から項目を選択できるようになりました。 この方法は、選択した項目ごとに項目オブジェクトを作成する必要がないため、項目の選択を記述するうえでより効率的です。 詳しくは、[ListViewBase.SelectedRanges](/uwp/api/windows.ui.xaml.controls.listviewbase.selectedranges)、[ListViewBase.SelectRange](/uwp/api/windows.ui.xaml.controls.listviewbase.selectrange)、[ListViewBase.DeselectRange](/uwp/api/windows.ui.xaml.controls.listviewbase.deselectrange) をご覧ください。
新しい ListViewItemPresenter API | [ListView](/uwp/api/windows.ui.xaml.controls.listview) と [GridView](/uwp/api/windows.ui.xaml.controls.gridview) では、項目プレゼンターを使って、選択とフォーカスの既定の視覚効果を提供します。 UWP アプリでは、[ListViewItemPresenter](/uwp/api/windows.ui.xaml.controls.primitives.listviewitempresenter) と [GridViewItemPresenter](/uwp/api/windows.ui.xaml.controls.primitives.gridviewitempresenter) に、リスト項目の視覚効果をさらにカスタマイズできる新しいプロパティがあります。 その新しいプロパティは、CheckBoxBrush、CheckMode、FocusSecondaryBorderBrush、PointerOverForeground、PressedBackground、SelectedPressedBackground です。
SemanticZoom の更新 | [SemanticZoom](/uwp/api/windows.ui.xaml.controls.semanticzoom) コントロールに、すべてのデバイス ファミリで一貫した UWP アプリ向けの動作が設定されました。 拡大表示ビューと縮小表示ビューを切り替える既定のアクションは、拡大表示ビューでグループ ヘッダーをタップすることです。 これは Windows Phone 8.1 での動作と同じですが、ズームにピンチ ジェスチャを使っていた Windows 8.1 でのそれとは異なります。 ピンチによるズームを使ってビューを変更するには、SemanticZoom の内部 ScrollViewer で [ScrollViewer.ZoomMode](/uwp/api/windows.ui.xaml.controls.scrollviewer.zoommode)="Enabled" を設定します。 <br /><br />ユニバーサル Windows アプリでは、拡大表示ビューが縮小表示ビューに置き換えられます。この縮小表示ビューのサイズは、置き換える前のビューと同じです。 これは Windows 8.1 での動作と同じですが、縮小表示ビューが画面全体を占有し、他のすべてのコンテンツの上にレンダリングされていた Windows Phone 8.1 でのそれとは異なります。
DatePicker および TimePicker の更新 | [DatePicker](/uwp/api/windows.ui.xaml.controls.datepicker) コントロールと [TimePicker](/uwp/api/windows.ui.xaml.controls.timepicker) コントロールに、すべてのデバイス ファミリで一貫したユニバーサル Windows アプリ向けの実装が設けられました。 Windows 10 向けに見た目も刷新されています。 コントロールのポップアップの部分では、すべてのデバイスで [DatePickerFlyout](/uwp/api/windows.ui.xaml.controls.datepickerflyout) コントロールと [TimePickerFlyout](/uwp/api/windows.ui.xaml.controls.timepickerflyout) コントロールが使われるようになりました。 これは、Windows Phone 8.1 での動作と同じですが、[ComboBox](/uwp/api/windows.ui.xaml.controls.combobox) コントロールを使っていた Windows 8.1 とは違っています。 ポップアップ コントロールを使うと、カスタマイズされた日付と時刻の選択機能を簡単に作成することができます。
新しい ScrollViewer API | [ScrollViewer](/uwp/api/windows.ui.xaml.controls.scrollviewer) に、タッチによるパンが開始および停止したときにアプリに通知する新しい [DirectManipulationStarted](/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted) イベントと [DirectManipulationCompleted](/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted) イベントが追加されました。 これらのイベントを処理することで、これらのユーザー アクションに合わせて UI を調整できます。
MenuFlyout の更新 | ユニバーサル Windows アプリには、優れたショートカット メニューをより簡単に作成できる新しい API があります。 新しい [MenuFlyout.ShowAt](/uwp/api/windows.ui.xaml.controls.menuflyout.showat) メソッドでは、別の要素の位置を基準にポップアップを表示する場所を指定できます (MenuFlyout は、アプリのウィンドウの境界線上に重ねることもできるようになりました)。カスケード メニューを作成するには、新しい [MenuFlyoutSubItem](/uwp/api/windows.ui.xaml.controls.menuflyoutsubitem) クラスを使います。
ContentPresenter、Grid、StackPanel の新しい Border プロパティ | 一般的なコンテナー コントロールに、XAML に Border 要素を追加せずに周囲に境界線を描画できる、新しい境界線プロパティが追加されました。 [ContentPresenter](/uwp/api/windows.ui.xaml.controls.contentpresenter)、[Grid](/uwp/api/windows.ui.xaml.controls.grid)、および [StackPanel](/uwp/api/windows.ui.xaml.controls.stackpanel) には、次に示す新しいプロパティがあります: BorderBrush、BorderThickness、CornerRadius、および Padding。
ContentPresenter の新しいテキスト API | [ContentPresenter](/uwp/api/windows.ui.xaml.controls.contentpresenter) には、テキスト表示をより細かく制御できる次の新しい API があります: LineHeight、LineStackingStrategy、MaxLines、および TextWrapping。
システムのフォーカスの視覚効果 | XAML コントロールのフォーカスの視覚効果は、コントロール テンプレートの XAML 要素として宣言するのではなく、システムによって作成されるようになりました。 フォーカスの視覚効果は通常、モバイル デバイスでは必要ないため、必要に応じてシステムで作成および管理されるようにすれば、アプリのパフォーマンスが向上します。 フォーカスのビジュアルをさらに制御する場合は、システムの動作を上書きし、フォーカスのビジュアルを定義するカスタム コントロール テンプレートを使います。 詳しくは、[UseSystemFocusVisuals](/uwp/api/windows.ui.xaml.controls.control.usesystemfocusvisuals) と [IsTemplateFocusTarget](/uwp/api/windows.ui.xaml.controls.control.istemplatefocustargetproperty) をご覧ください。
PasswordBox.PasswordRevealMode | ユニバーサル Windows アプリでは、デバイス ファミリ間で一貫性のある動作を提供するために、IsPasswordRevealButtonEnabled が [PasswordRevealMode](/uwp/api/windows.ui.xaml.controls.passwordbox.passwordrevealmode) プロパティに置き換えられます。 **注:** Windows 10 より前のバージョンでは、パスワードを表示するボタンは既定では表示されませんでしたが、ユニバーサル Windows アプリでは既定で表示されます。 アプリのセキュリティにより、パスワードを必ず非表示にする必要がある場合は、PasswordRevealMode を Hidden に設定してください。
Control.IsTextScaleFactorEnabled | Windows Phone 8.1 で使用できた [IsTextScaleFactorEnabled](/uwp/api/windows.ui.xaml.controls.control.istextscalefactorenabledproperty) プロパティは、すべてのデバイス ファミリのユニバーサル Windows アプリで使用できるようになりました。
AutoSuggestBox | Windows Phone 8.1 の [AutoSuggestBox](/uwp/api/windows.ui.xaml.controls.autosuggestbox) コントロールは、すべてのデバイス ファミリのユニバーサル Windows アプリで利用できるようになりました。このコントロールは、[SearchBox](/uwp/api/windows.ui.xaml.controls.searchbox) の代わりに使用する必要があります。 AutoSuggestBox は、ユーザーによる入力の際に候補を提供します。タッチ、キーボード、入力方式エディターなど、さまざまな種類の入力に対応しています。 検索ボックスとしての機能を高める新しいメンバーも追加されています。[QueryIcon](/uwp/api/windows.ui.xaml.controls.autosuggestbox.queryicon) プロパティと [QuerySubmitted](/uwp/api/windows.ui.xaml.controls.autosuggestbox.querysubmitted) イベントです。
ContentDialog | Windows Phone 8.1 の [ContentDialog](/uwp/api/windows.ui.xaml.controls.contentdialog) コントロールは、すべてのデバイス ファミリのユニバーサル Windows アプリで使用できるようになりました。 ContentDialog を使えば、ありとあらゆるデバイスで適切に機能するカスタマイズ可能なモーダル ダイアログを表示できます。
Pivot | Windows Phone 8.1 の [Pivot](/uwp/api/windows.ui.xaml.controls.pivot) コントロールは、すべてのデバイス ファミリのユニバーサル Windows アプリで使用できるようになりました。 モバイル デバイスとデスクトップ デバイスに対応したアプリで、同じ Pivot コントロールを使用できるようになりました。 Pivot は、画面サイズと入力の種類に基づいてアダプティブ動作を提供します。 各ピボット項目の異なる情報のビューで、タブに似た動作を提供するように Pivot コントロールのスタイルを指定できます。

## <a name="text"></a>テキスト

機能 | 説明
 :---- | :----
Windows の基本的なテキスト API | 新しい [Windows.UI.Text.Core](/uwp/api/windows.ui.text.core) 名前空間は、キーボード入力の処理を単一のサーバーで集中管理するクライアント サーバー システムを備えています。 そのシステムを使ってカスタム テキスト入力コントロールの編集バッファーを操作できます。 テキスト入力サーバーは、アプリとサーバーの間の非同期通信チャネルを介して、テキスト入力コントロールの内容と、そのコントロール独自の編集バッファーの内容を常に同期した状態に保ちます。
ベクター アイコン | [Glyphs](/uwp/api/windows.ui.xaml.documents.glyphs) 要素には、カラー フォントをサポートする新しい [IsColorFontEnabled](/uwp/api/windows.ui.xaml.documents.glyphs.iscolorfontenabled) プロパティと [ColorFontPalleteIndex](/uwp/api/windows.ui.xaml.documents.glyphs.colorfontpaletteindex) プロパティがあります。そのため、フォント ファイルを使って、フォント ベースのアイコンをレンダリングできるようになりました。 カラー パレットの切り替えに ColorFontPalleteIndex を使うと、1 つのアイコンを異なるカラー セットを使ってレンダリングできます。たとえば、アイコンの有効バージョンと無効バージョンを表示できます。
入力方式エディター ウィンドウのイベント | ユーザーは、テキスト入力ボックスのすぐ下のウィンドウに表示される入力方式エディターを使ってテキストを入力することがあります (通常、東アジア言語の場合)。 [TextBox](/uwp/api/windows.ui.xaml.controls.textbox) と [RichEditBox](/uwp/api/windows.ui.xaml.controls.richeditbox) の CandidateWindowBoundsChanged イベントと DesiredCandidateWindowAlignment プロパティを使うと、アプリの UI で IME ウィンドウをより適切に表示させることができます。
テキスト作成イベント | [TextBox](/uwp/api/windows.ui.xaml.controls.textbox) と [RichEditBox](/uwp/api/windows.ui.xaml.controls.richeditbox) には、入力方式エディターを使用してテキストを作成するときにご利用のアプリに通知する次の新しいイベントがあります: TextCompositionStarted、TextCompositionEnded、および TextCompositionChanged。 これらのイベントを処理することで、IME のテキスト作成プロセスに合わせてアプリのコードを調整できます。 たとえば、東アジア言語のインライン オートコンプリート機能を実装できます。
双方向テキストの処理の改善 | XAML テキスト コントロールの新しい API により、双方向テキストの処理が改善され、さまざまな入力言語においてテキストの配置と段落の方向がより正確に認識されるようになりました。 TextReadingOrder プロパティの既定値が DetectFromContent に変更されたため、読む方向の検出のサポートが既定で有効になります。 また、PasswordBox、RichEditBox、TextBox にも TextReadingOrder プロパティが追加されました。 テキスト コントロールの TextAlignment プロパティを新しい DetectFromContent 値に設定すると、配置をコンテンツから自動的に検出できます。
テキストの描画 | Windows 10 では、ほとんどの状況で、XAML アプリのテキストが Windows 8.1 のほぼ 2 倍の速度で描画されます。 ほとんどの場合は、変更しなくても、アプリでこの速度向上の恩恵を受けることができます。 また、描画速度の向上のほかにも、XAML アプリの一般的なメモリ消費量が 5% 減少します。

## <a name="application-model"></a>アプリケーション モデル

機能 | 説明
 :---- | :----
Cortana | 音声コマンドが Cortana の基本機能を拡張し、外部アプリケーションで単一の操作を起動して実行します。 アプリの基本的な機能を統合して、ユーザーが直接アプリを開かずにほとんどのタスクを実行できる中心的エントリ ポイントを提供することで、Cortana は、アプリとユーザーの仲介役となります。 多くの場合、これによってユーザーの時間と労力を大幅に減らすことができます。 [Cortana のキャンバスにアプリを統合](/previous-versions/windows/apps/dn974230(v=win.10))する方法について説明します。 アイデアが必要な場合は、[ユニバーサル Windows アプリの設計の基本](../design/layout/index.md)に関するページで、Cortana に固有の設計に関する推奨事項とユーザー エクスペリエンスのガイドラインをご確認いただけます。
エクスプローラー | 新しい [Windows.System.Launcher.LaunchFolderAsync](/uwp/api/windows.system.launcher.launchfolderasync) メソッドでは、エクスプローラーを起動して、指定したフォルダーの内容を表示できます。
共有ストレージ | 新しい [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](/uwp/api/windows.applicationmodel.datatransfer.sharedstorageaccessmanager) クラスとそのメソッドでは、URI のアクティブ化を使って他のアプリを起動するときに共有トークンを渡し、別のアプリとファイルを共有できます。 ターゲット アプリはトークンを利用して、ソース アプリが共有しているファイルを取得します。
Settings | ms-settings プロトコルと [LaunchUriAsync](/uwp/api/windows.system.launcher.launchuriasync) メソッドを使って組み込みの設定ページを表示できます。 たとえば、次のコードは Wi-Fi の設定ページを表示します。 **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />表示できる設定ページの一覧については、「[ms-settings プロトコルを使って組み込みの設定ページを表示する方法](/previous-versions/windows/apps/jj207014(v=vs.105))」を参照してください。
App-to-App communication | Windows 10 の新しい[アプリ間通信](/previous-versions/windows/apps/dn997827(v=win.10)) API により、Windows アプリケーション (および Windows Web アプリケーション) 間での相互起動やデータとファイルの交換が可能になります。 これらの新しい API を使うと、複数のアプリケーションを使う必要のあった複雑な作業をシームレスに処理できるようになります。 たとえば、アプリでソーシャル ネットワー キング アプリを起動して連絡先を選択したり、チェックアウト アプリケーションを起動して支払処理を完了したりできます。
アプリ サービス | アプリ サービスは、Windows 10 でアプリが他のアプリにサービスを提供する方法の 1 つです。 アプリ サービスは、バックグラウンド タスクの形式を取ります。 フォアグラウンド アプリは、別のアプリでアプリ サービスを呼び出してバックグラウンドでタスクを実行できます。 アプリ サービス API のリファレンス情報については、[Windows.ApplicationModel.AppService](/uwp/api/Windows.ApplicationModel.AppService) をご覧ください。
アプリ パッケージ マニフェスト | Windows 10 の[パッケージ マニフェスト スキーマ](/uwp/schemas/appxpackage/appx-package-manifest)のリファレンスへの更新には、追加、削除、変更された要素が含まれています。 このスキーマのすべての要素、属性、タイプに関するリファレンス情報については、「[要素の階層](/uwp/schemas/appxpackage/uapmanifestschema/root-elements)」をご覧ください。

## <a name="devices"></a>デバイス

機能 | 説明
 :---- | :----
Microsoft Surface Hub | Microsoft Surface Hub は、高性能なチーム共同作業デバイスであり、Surface Hub または接続されているデバイスからネイティブで実行されるユニバーサル Windows アプリに対応する大画面プラットフォームです。 ビジネス向けの独自アプリを作成し、大画面、タッチ入力、手描き入力、広範なオンボード ハードウェア (カメラ、センサーなど) を活用しましょう。<br /><br />[ユニバーサル Windows アプリの設計の基本](../design/layout/index.md)に関するページで、Surface Hub に固有の設計に関する推奨事項とユーザー エクスペリエンスのガイドラインをご確認いただけます。 次のドキュメントでは、ユニバーサル Windows アプリのレスポンシブ デザイン手法を説明しています。 <br /><br />共同の共有アプリのサポートについては、[SharedModeSettings](/uwp/api/windows.system.profile.sharedmodesettings) に関するページをご覧ください。 手描き入力と新しい [InkCanvas](/uwp/api/windows.ui.xaml.controls.inkcanvas) コントロールでのマルチポイント手描き入力のサポートについて詳しくは、[Windows.UI.Input.Inking](/uwp/api/windows.ui.input.inking) に関するページと [Windows.UI.Input.Inking.Core](/uwp/api/windows.ui.input.inking.core) に関するページをご覧ください。 センサー入力の処理については、[デバイス、プリンター、センサーの統合](/previous-versions/windows/apps/br229563(v=win.10))に関するページをご覧ください。
インストール先 | Windows 10 では、位置情報へのアクセス許可をユーザーに求める画面を表示する新しいメソッド、[RequestAccessAsync](/uwp/api/windows.devices.geolocation.geolocator.requestaccessasync) が導入されます。 ユーザーが **設定** アプリの **位置情報に関するプライバシー設定** で位置情報に関するプライバシーを設定します。 次の場合にのみ、アプリでユーザーの位置情報にアクセスできます。 **[このデバイスの位置情報]** がオンになっている場合 *(Windows 10 for phones には適用されません)* 、位置情報サービス設定の " **[位置情報]** " がオンになっている場合、 **[位置情報を使えるようにするアプリを選ぶ]** で、アプリがオンになっている場合。 <br /><br />ユーザーの位置情報にアクセスする前に、 **RequestAccessAsync** を呼び出すことが重要です。 このときに、アプリをフォアグラウンドで実行し、 **RequestAccessAsync** を UI スレッドから呼び出す必要があります。 位置情報に対するアクセス許可をユーザーがアプリに与えるまで、アプリは位置情報にアクセスできません。
AllJoyn | [Windows.Devices.AllJoyn](/uwp/api/windows.devices.alljoyn) Windows ランタイム名前空間には、AllJoyn オープン ソース ソフトウェア フレームワークとサービスのマイクロソフトによる実装が導入されています。 これらの API により、Windows デバイス用のユニバーサル アプリは、AllJoyn に基づくモノのインターネット (IoT) のシナリオに他のデバイスと共に参加できるようになります。 AllJoyn C API について詳しくは、[AllSeen Alliance](https://allseenalliance.org/) でドキュメントをダウンロードしてください。 デバイス アプリでの AllJoyn シナリオの実現に使用できる Windows コンポーネントを生成するには、このリリースに含まれている [AllJoynCodeGen](/previous-versions/windows/apps/dn913809(v=win.10)) ツールを使います。 <br /><br />**注:** Windows 10 IoT Core が、小型デバイス用の新しいクラスで使用できるようになりました。これで、Windows と Visual Studio を使って "モノのインターネット" (IoT) デバイスを作成できます。 詳しくは、[Windows デベロッパー センターで Windows IoT](https://developer.microsoft.com/windows/iot) についてご覧ください。
モバイルでの印刷 API (XAML) | There is a single, unified set of APIs that let you print from your XAML-based UWP apps across device families, including mobile devices. Windows.Graphics.Printing 名前空間と Windows.UI.Xaml.Printing 名前空間の慣れ親しんでいる印刷関連の API を使って、印刷機能をモバイル アプリに追加できるようになりました。
バッテリ | [Windows.Devices.Power](/uwp/api/windows.devices.power) 名前空間のバッテリー API を使うと、アプリを実行しているデバイスに接続されたバッテリーについて、詳しい情報をアプリで取得できます。 個々のバッテリー コントローラーまたはすべてのバッテリー コントローラーの集合を表す [Battery](/uwp/api/windows.devices.power.battery) オブジェクトを作成します (それぞれ、[FromIdAsync](/uwp/api/windows.devices.power.battery.fromidasync) または [AggregateBattery](/uwp/api/windows.devices.power.battery.aggregatebattery) によって作成されている場合)。 [GetReport](/uwp/api/windows.devices.power.battery.getreport) メソッドを使って、対応するバッテリーの充電量、容量、状態を示す [BatteryReport](/uwp/api/windows.devices.power.batteryreport) オブジェクトを取得します。
MIDI デバイス | 新しい [Windows.Devices.Midi](/uwp/api/windows.devices.midi) 名前空間では、外部 MIDI デバイスと通信可能なアプリ、Microsoft GS MIDI ソフトウェア シンセサイザーと直接通信するアプリと外部デバイス、複数のクライアントが同時に 1 つの MIDI ポートにアクセスするシナリオを作成できます。
カスタム センサーのサポート | [Windows.Devices.Sensors.Custom](/uwp/api/windows.devices.sensors.custom) 名前空間により、ハードウェアの開発者は CO2 センサーのような新しいカスタム センサーの種類を定義できます。
ホスト ベースのカード エミュレーション (HCE) | ホスト カード エミュレーションを使うと、OS でホストされている NFC カード エミュレーション サービスを実装すると同時に、NFC 無線経由で外部リーダー ターミナルと通信することができます。 バックグラウンド タスクをトリガーして NFC 経由でスマートカードをエミュレートするには、[SmartCardTrigger](/uwp/api/Windows.ApplicationModel.Background.SmartCardTrigger) クラスを使います。 [SmartCardTriggerType](/uwp/api/Windows.Devices.SmartCards.SmartCardTriggerType) 列挙型の EmulatorHostApplicationActivated 値によりアプリは、HCE イベントが発生したことを認識します。

## <a name="graphics"></a>グラフィックス

機能 | 説明
 :---- | :----
DirectX | Windows 10 の DirectX 12 では、DirectX の核となる 3D グラフィックス API である Microsoft Direct3D の次期バージョンが導入されます。 [Direct3D 12 グラフィックス](/windows/desktop/direct3d12/direct3d-12-graphics)は、コンソールに似た低水準 API の効率性とパフォーマンスを実現します。 Direct3D 12 は、これまで以上に高速で高い効率性を発揮します。 より豊かなシーン、より多くのオブジェクト、より複雑な効果を実現し、最新のグラフィックス ハードウェアをより有効に活用できます。
SoftwareBitmapSource | ユニバーサル Windows アプリでは、XAML 画像のソースとして新しい [SoftwareBitmapSource](/uwp/api/windows.ui.xaml.media.imaging.softwarebitmapsource) を使うことができます。 これにより、エンコードされていない画像を XAML フレームワークに渡し、XAML フレームワークによる画像のデコードをバイパスして、すぐに画面に表示することができます。 カメラから直接低遅延で写真をレンダリングする、カスタムの画像デコーダーを使う、DirectX サーフェイスからフレームをキャプチャする、メモリ内の画像をゼロから作成し、待機時間とメモリのオーバーヘッドを低く抑えながら XAML で直接すべてレンダリングするなど、非常に高速な画像のレンダリングを実現できます。
遠近投影カメラ | ユニバーサル Windows アプリでは、XAML の新しい Transform3D API を使って、XAML ツリー (シーン) に遠近法変換を適用することができます。適用すると、その 1 つのシーン全体の変換 (カメラ) に従ってすべての XAML 子要素が変換されます。 従来は、これを実現するには、MatrixTransform と複雑な数式を使う必要がありましたが、Transform3D によりその作業が大幅に簡略化されるうえに、この効果をアニメーション化することもできます。 詳しくは、[UIElement.Transform3D](/uwp/api/windows.ui.xaml.uielement.transform3d) プロパティ、[Transform3D](/uwp/api/windows.ui.xaml.media.media3d.transform3d)、[CompositeTransform3D](/uwp/api/windows.ui.xaml.media.media3d.compositetransform3d)、[PerspectiveTransform3D](/uwp/api/windows.ui.xaml.media.media3d.perspectivetransform3d) をご覧ください。

## <a name="media"></a>メディア

機能 | 説明
 :---- | :----
HTTP ライブ ストリーミング | 新しい [AdaptiveMediaSource](/uwp/api/windows.media.streaming.adaptive.adaptivemediasource) クラスを使って、アダプティブ ビデオ ストリーミング機能をアプリに追加できます。 ストリーミング マニフェスト ファイルを指定してオブジェクトを初期化します。 サポートされているマニフェストの形式として、Http Live Streaming (HLS) と Dynamic Adaptive Streaming over HTTP (DASH) があります。 オブジェクトの XAML メディア要素にバインドされると、アダプティブ再生が始まります。 利用可能なビットレート、最小ビットレート、最大ビットレートなどのストリームのプロパティを照会して、必要に応じて設定できます。
メディア ファンデーションの Transcode Video Processor (XVP) によるメディア ファンデーション トランスフォーム (MFT) のサポート | メディア ファンデーション トランスフォーム (MFT) を利用する Windows アプリでは、 **メディア ファンデーションの Transcode Video Processor** (XVP) を使って、生のビデオ データを変換、拡大縮小、変形することができます。新しい [MF_XVP_CALLER_ALLOCATES_OUTPUT](/windows/desktop/medfound/mf-xvp-caller-allocates-output) 属性では、Microsoft DirectX ビデオ アクセラレーション (DXVA) モードであっても、呼び出し元によって割り当てられたテクスチャへの出力ができます。 新しい [IMFVideoProcessorControl2](/windows/desktop/api/mfidl/nn-mfidl-imfvideoprocessorcontrol2) インターフェイスでは、アプリでハードウェア効果を有効にし、サポートされているハードウェア効果を照会して、ビデオ プロセッサによって実行される回転操作をオーバーライドすることができます。
コード変換 | 新しい [MediaProcessingTrigger](/uwp/api/Windows.ApplicationModel.Background.MediaProcessingTrigger) API では、アプリでメディアのトランスコードをバックグラウンド タスクとして実行することができます。これにより、フォアグラウンド アプリが終了してもトランスコード処理を続けることができます。
MediaElement のメディア エラー イベント | ユニバーサル Windows アプリでは、メディア コンテンツに少なくとも 1 つの有効なストリームがある限り、いずれかのストリームのデコードでエラーが発生しても、[MediaElement](/uwp/api/Windows.UI.Xaml.Controls.MediaElement) が複数のストリームを含むコンテンツを再生します。 たとえば、オーディオとビデオ ストリームを含むコンテンツのビデオ ストリームが失敗した場合は、[MediaElement](/uwp/api/Windows.UI.Xaml.Controls.MediaElement) がオーディオ ストリームの再生を続けます。 [PartialMediaFailureDetected](/uwp/api/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected) によってストリーム内のいずれかのストリームがデコードできなかったことが通知されます。 また、失敗したストリームの種類も通知されるため、その情報を UI に反映することができます。 メディア ストリーム内のすべてのストリームが失敗した場合は [MediaFailed](/uwp/api/windows.ui.xaml.controls.mediaelement.mediafailed) イベントが発生します。
MediaElement を使ったアダプティブ ビデオ ストリーミングのサポート | [MediaElement](/uwp/api/Windows.UI.Xaml.Controls.MediaElement) には、アダプティブ ビデオ ストリーミングをサポートする新しい [SetPlaybackSource](/uwp/api/windows.ui.xaml.controls.mediaelement.setplaybacksource) メソッドがあります。 このメソッドを使って、メディア ソースを AdaptiveMediaSource に設定します。
MediaElement と Image を使ったキャスト | [MediaElement](/uwp/api/Windows.UI.Xaml.Controls.MediaElement) コントロールと Image コントロールには、新しい [GetAsCastingSource](/uwp/api/windows.ui.xaml.controls.mediaelement.getascastingsource) メソッドがあります。 このメソッドを使うと、メディア要素や画像要素のコンテンツを Miracast、Bluetooth、DLNA などのさまざまなリモート デバイスにプログラムで送信できます。 この機能は、MediaElement の [AreTransportControlsEnabled](/uwp/api/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled) を true に設定すると、自動的に有効になります。
デスクトップ アプリ用メディア トランスポート コントロール | [ISystemMediaTransportControls](/previous-versions/windows/desktop/mediatransport/isystemmediatransportcontrols) インターフェイスと、関連する API によってデスクトップ アプリが組み込みのシステム メディア トランスポート コントロールを操作できるようにします。 これには、トランスポート コントロール ボタンによるユーザー操作への応答と、現在再生中のメディア コンテンツに関するメタデータを表示するためのトランスポート コントロールの表示の更新が含まれます。
ランダム アクセス JPEG エンコードとデコード | 新しい WIC メソッドである [IWICJpegFrameEncode](/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframeencode) と [IWICJpegFrameDecode](/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframedecode) によって JPEG 画像のエンコードとデコードを実現します。 画像データのインデックス化もできるようになったので、メモリを大量に消費する大きい画像のランダム アクセスも効率的に実行することができます。
メディア コンポジション用オーバーレイ | 新しい [MediaOverlay](/uwp/api/Windows.Media.Editing.MediaOverlay) API と [MediaOverlayLayer](/uwp/api/Windows.Media.Editing.MediaOverlayLayer) API によって、静的または動的なメディア コンテンツからなる複数のレイヤーをメディア コンポジションに追加するのがこれまでより簡単になりました。 レイヤーごとに不透明度、位置、およびタイミングを調整できるので、入力レイヤー用の独自のカスタム コンポジターを実装することもできます。
新しい効果フレームワーク | [Windows.Media.Effects](/uwp/api/windows.media.effects) 名前空間では、オーディオとビデオ ストリームに効果を追加するためのシンプルで直感的なフレームワークが提供されます。 このフレームワークには、独自のオーディオ エフェクトやビデオ エフェクトを作成してメディア パイプラインに挿入するために実装できる基本的なインターフェイスが含まれています。

## <a name="networking"></a>ネットワーク

機能 | 説明
 :---- | :----
ソケット | ソケットの更新内容には、次の項目が含まれます。 <br /><br />**ソケット ブローカー:** ソケット ブローカーは、アプリのライフサイクルのすべての状態において、アプリに代わってソケット接続を確立し、閉じることができます。 これにより、アプリとアプリの提供するサービスが、より見つけやすくなります。 ソケット ブローカーを経由すると、たとえば Win32 サービスは、実行中でないときでも受信ソケット接続を受け付けることができます。 <br /><br />**スループットの向上:** ソケットのスループットが、Windows.Networking.Sockets 名前空間を使うアプリ用に最適化されています。
バックグラウンド転送の後処理タスク | [Windows.Networking.BackgroundTransfer](/uwp/api/windows.networking.backgroundtransfer) 名前空間の新しい API を使うと、後処理タスクのグループを登録できます。 これによりアプリは、フォアグラウンドでない場合でも、バックグラウンド転送の成功または失敗に対してすぐに対応でき、ユーザーが次回アプリを再開するときまで待つ必要がありません。
広告に対する Bluetooth サポート | [Windows.Devices.Bluetooth.Advertisement](/uwp/api/windows.devices.bluetooth.advertisement) 名前空間を使うと、アプリで Bluetooth LE アドバタイズの送受信やフィルター処理を行うことができます。
Wi-Fi Direct API の更新内容 | デバイス ブローカーが更新され、アプリを離れることなくデバイスのペアリングができるようになりました。 [Windows.Devices.WiFiDirect](/uwp/api/windows.devices.wifidirect) 名前空間に行われた追加により、デバイスを他のデバイスから検出できるようにしたり、デバイスで着信接続の通知を待機したりできます。<br /><br />**注:** このリリースでは、Wi-Fi Direct の機能強化は UX に組み込まれておらず、プッシュ ボタンによるペアリングのみがサポートされています。 また、このリリースでは、サポートされるアクティブな接続は 1 つだけです。
JSON サポートの強化 | [Windows.Data.Json](/uwp/api/windows.data.json) 名前空間では、デバッグ セッションで JSON オブジェクトを変換する場合に、既存の標準定義のサポートと開発者エクスペリエンスが強化されています。

## <a name="security"></a>セキュリティ

機能 | 説明
 :---- | :----
ECC 暗号化 | [Windows.Security.Cryptography](/uwp/api/windows.security.cryptography) 名前空間の新しい API では、楕円曲線暗号 (ECC) がサポートされています。ECC は、有限体上の楕円曲線に基づく公開キー暗号化の実装です。 ECC は数学的に RSA よりも複雑であり、キーのサイズが小さいため、メモリ消費が削減されてパフォーマンスが向上します。 ECC は Microsoft サービスとお客様に、RSA キーや NIST によって承認された曲線のパラメーターに代わる方法を提供します。
Microsoft Passport | Microsoft Passport は、パスワードの代わりに非対称暗号方式とジェスチャを使う、もう 1 つの認証方法です。 [KeyCredentialManger](/uwp/api/windows.security.credentials.keycredentialmanager) など、Credentials 名前空間のクラスにより、開発者は、複雑な暗号または生体認証を使わずに、Microsoft Passport を使用して簡単にアプリケーションを作成できます。
Microsoft Passport for Work | 業務用 Microsoft Passport は、パスワード、スマート カード、仮想スマート カードを使用しない Azure Active Directory アカウントを使って Windows にサインインする、もう 1 つの方法です。 このポリシー設定は、有効にするか、無効するかを選択できます。
トークン ブローカー | トークンのブローカーは、アプリがオンライン ID プロバイダー (Facebook など) に接続しやすくなる新しい認証フレームワークです。 アカウントのユーザー名とパスワードの管理や、効率の高い UI などの機能により、ユーザーの認証エクスペリエンスが大幅に改善されます。

## <a name="system-services"></a>システム サービス

機能 | 説明
 :---- | :----
Power | バッテリー節約機能が有効または無効になったときは、Windows デスクトップ アプリケーションに通知されるようになりました。 電源状態の変化がわかるようになるので、アプリを調整してバッテリー駆動時間を引き延ばすことができるようになります。 <br /><br />[GUID_POWER_SAVING_STATUS](/windows/desktop/Power/power-setting-guids): この新しい GUID と [PowerSettingRegisterNotification](/windows/desktop/api/powersetting/nf-powersetting-powersettingregisternotification) 関数を併用して、バッテリー節約機能が有効または無効になったときに通知されるようにします。 <br /><br />[SYSTEM_POWER_STATUS](/windows/desktop/api/winbase/ns-winbase-_system_power_status): バッテリー節約機能をサポートするためにこの構造体が更新されました。 4 番目の *SystemStatusFlag* (以前の Reserved1) は、バッテリ セーバーが有効または無効になっていることを示すようになりました。 [GetSystemPowerStatus](/windows/desktop/api/winbase/nf-winbase-getsystempowerstatus) 関数を使ってこの構造体へのポインターを取得します。
バージョン | [Version Helper 関数](/windows/desktop/SysInfo/version-helper-apis)を使ってオペレーティング システムのバージョンを調べることができます。 Windows 10 では、これらのヘルパー関数に新しい関数である [IsWindows10OrGreater](/windows/desktop/api/versionhelpers/nf-versionhelpers-iswindows10orgreater) が含まれています。 オペレーティング システムのバージョンを調べる際は、非推奨の [GetVersionEx](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) 関数と [GetVersion](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) 関数ではなく、新しい関数を使用します。 システム バージョンを取得する方法の詳細については、「[システム バージョンの取得](/windows/desktop/SysInfo/getting-the-system-version)」を参照してください。 <br /><br />非推奨の [GetVersionEx](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) 関数または [GetVersion](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) 関数を使って [OSVERSIONINFOEX](/windows/desktop/api/winnt/ns-winnt-_osversioninfoexa) 構造体または [OSVERSIONINFO](/windows/desktop/api/winnt/ns-winnt-_osversioninfoa) 構造体からバージョン情報を取得する場合は、これらの構造体に含まれるバージョン番号が、Windows 8.1 と Windows Server 2012 R2 のバージョン番号である 6.3 から、Windows 10 のバージョン番号である 10.0 に増加する点に注意してください。 オペレーティング システムのバージョン番号の詳細については、「[オペレーティング システムのバージョン](/windows/desktop/SysInfo/operating-system-version)」を参照してください。 <br /><br />また、[GetVersionEx](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) 関数または [GetVersion](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) 関数でこれらのバージョンの正しいバージョン情報を取得するには、アプリで Windows 8.1 または Windows 10 を明示的に指定する必要があります。 これらのバージョンの Windows をアプリで指定する方法について詳しくは、[アプリで Windows を指定する方法](/windows/desktop/SysInfo/targeting-your-application-at-windows-8-1)に関するページをご覧ください。
ユーザー情報 | [Windows.System](/uwp/api/windows.system) 名前空間の新しい API により、ユーザー名やアカウントの画像など、ユーザーに関する情報にアクセスしやすくなります。 ログインやログアウトなどのユーザー イベントに応答する機能も提供されます。
メモリ管理とプロファイリング | [Windows.System](/uwp/api/windows.system) のメモリ プロファイリング API のサポートがすべてのプラットフォームに拡張され、その全体的な機能が、新しいクラスと機能で強化されています。

## <a name="storage"></a>記憶域

機能 | 説明
 :---- | :----
Windows Phone で利用可能なファイル検索 API | アプリの発行者は、アプリ マニフェストに拡張機能を追加し、アプリを登録して、発行する他のアプリとストレージ フォルダーを共有できます。 共有したストレージの場所を取得するには、[Windows.Storage.ApplicationData.GetPublisherCacheFolder](/uwp/api/windows.storage.applicationdata.getpublishercachefolder) メソッドを呼び出します。 Windows ランタイム アプリの強力なセキュリティ モデルでは、一般的にアプリ間でのデータ共有はできません。 しかし、同じ発行元のアプリ間では、ユーザー単位でファイルと設定を共有すると便利な場合があります。

## <a name="tools"></a>ツール

機能 | 説明
 :---- | :----
Visual Studio のライブ ビジュアル ツリー機能 | Visual Studio に、新しいライブ ビジュアル ツリー機能が搭載されました。 デバッグの際にこの機能を使うことで、アプリのビジュアル ツリーの状態をすばやく把握し、要素のプロパティの設定を検出することができます。 It also lets you change property values while your app is running, so you can tweak and experiment without having to re-launch.
Trace logging | [TraceLogging](/windows/desktop/tracelogging/trace-logging-portal) は、ユーザー モード アプリとカーネル モード ドライバー用の新しいイベント トレース API です。[Windows イベント トレーシング](/windows/desktop/ETW/event-tracing-portal) (ETW) を基にして構築されています。 This API provides a simplified way to instrument code and include structured data with events without requiring a separate instrumentation manifest XML file. 対象となるさまざまな開発者に対応するために、WinRT、.NET、C/C++ の TraceLogging API が用意されています。

## <a name="user-experience"></a>ユーザーの作業

機能 | 説明
 :---- | :----
音声認識 | 長時間ディクテーション シナリオ向けの継続的な音声認識が、ユニバーサル Windows プラットフォームでサポートされるようになりました。 継続的なディクテーションを有効にする方法については、音声操作に関するドキュメントをご覧ください。
さまざまなアプリケーション プラットフォーム間でのドラッグ アンド ドロップ機能 | 新しい [Windows.ApplicationModel.DataTransfer.DragDrop](/uwp/api/windows.applicationmodel.datatransfer.dragdrop) 名前空間により、ユニバーサル Windows アプリでドラッグ アンド ドロップ機能が提供されます。 従来、デスクトップ プログラムの一般的なドラッグ アンド ドロップ シナリオ (フォルダーから Outlook のメール メッセージにドキュメントをドラッグして添付するなど) は、ユニバーサル Windows アプリでは実現できませんでした。 これらの新しい API をアプリで使うと、ユーザーはさまざまなユニバーサル Windows アプリとデスクトップの間でデータを簡単に移動できます。 <br /><br />アプリ間でのドラッグ アンド ドロップをサポートするために、次の新しい API が XAML に追加されました。[ListViewBase.DragItemsCompleted](/uwp/api/windows.ui.xaml.controls.listviewbase.dragitemscompleted) <br />UIElement: [CanDrag](/uwp/api/windows.ui.xaml.uielement.candrag)、[DragStarting](/uwp/api/windows.ui.xaml.uielement.dragstarting)、[StartDragAsync](/uwp/api/windows.ui.xaml.uielement.startdragasync)、[DropCompleted](/uwp/api/windows.ui.xaml.uielement.dropcompleted)。  <br />[DragOperationDeferral](/uwp/api/windows.ui.xaml.dragoperationdeferral)、[DragUI](/uwp/api/windows.ui.xaml.dragui)、[DragUIOverride](/uwp/api/windows.ui.xaml.draguioverride) <br />DragEventArgs: [AcceptedOperation](/uwp/api/windows.ui.xaml.drageventargs.acceptedoperation)、[DataView](/uwp/api/windows.ui.xaml.drageventargs.dataview)、[DragUIOverride](/uwp/api/windows.ui.xaml.drageventargs.draguioverride)、[GetDeferral](/uwp/api/windows.ui.xaml.drageventargs.getdeferral)、[Modifiers](/uwp/api/windows.ui.xaml.drageventargs.modifiers)。 <br />[DragItemsCompletedEventArgs](/uwp/api/windows.ui.xaml.controls.dragitemscompletedeventargs)、[DropCompletedEventArgs](/uwp/api/windows.ui.xaml.dropcompletedeventargs)、[DragStartingEventArgs](/uwp/api/windows.ui.xaml.dragstartingeventargs)
カスタム ウィンドウ タイトル バー | デスクトップ デバイス ファミリの UWP アプリで、[ApplicationViewTitleBar](/uwp/api/windows.ui.viewmanagement.applicationviewtitlebar) クラスと [ApplicationView.TitleBar](/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) プロパティおよび [Window.SetTitleBar](/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) メソッドを組み合わせて使うことで、既定の Windows タイトル バーのコンテンツを独自のカスタム XAML コンテンツに置き換えることができるようになりました。 カスタム XAML は "システム クロム" として扱われるため、入力イベントはアプリではなく Windows によって処理されます。 そのため、カスタム タイトル バーのコンテンツをクリックした場合でも、ユーザーはウィンドウをドラッグしたり、サイズを変更したりできます。

## <a name="web"></a>Web

機能 | 説明
 :---- | :----
Microsoft Edge | Microsoft Edge は、Windows 10 用にビルドされた新しい既定のブラウザーです。 最新の JavaScript 機能など、Microsoft Edge に含まれている開発者向けの機能と標準の概要について詳しくは、「[Microsoft Edge Developer Guide](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide)」(Microsoft Edge 開発者向けガイド)をご覧ください。
WebView による閲覧 | [WebView](/uwp/api/windows.ui.xaml.controls.webview) コントロールは、新しい Microsoft Edge ブラウザーと同じレンダリング エンジンを使います。 これにより、最も正確な、HTML 規格に準拠したモードでレンダリングを実行することができます。
オフ スレッド WebView | [WebView.ExecutionMode](/uwp/api/windows.ui.xaml.controls.webview.executionmode) を指定することで、Web コンテンツの処理と表示を別々のバック グラウンド スレッドで実行できます。 これにより、特定のシナリオでパフォーマンスを改善することができます。
WebView.UnsupportedUriSchemeIdentified イベント | 新しい [WebView.UnsupportedUriSchemeIdentified](/uwp/api/windows.ui.xaml.controls.webview.unsupportedurischemeidentified) イベントを使用して、アプリにおけるサポートされない URI スキームの処理方法を指定できます。 このイベントを処理することで、サポートされない URI スキームのカスタム処理をアプリで実行できます。 HTML WebView コントロールについては、[MSWebViewUnsupportedUriSchemeIdentified](/previous-versions/windows/apps/dn803906(v=win.10)) イベントの説明をご覧ください。
WebView.NewWindowRequested イベント | 新しい [WebView.NewWindowRequested](/uwp/api/windows.ui.xaml.controls.webview.newwindowrequested) イベントを利用して、WebView のスクリプトで新しいブラウザー ウィンドウが要求されたときに応答することができます。 HTML WebView コントロールについては、[MSWebViewNewWindowRequested](/microsoft-edge/webview) イベントの説明をご覧ください。
WebView.PermissionRequested イベント | 新しい [WebView.PermissionRequested](/uwp/api/windows.ui.xaml.controls.webview.permissionrequested) イベントにより、位置情報のようなユーザーから特別な許可を得る必要がある新しい HTML5 API の充実した機能を WebView コンテンツで利用できるようになります。 HTML WebView コントロールについては、[MSWebViewPermissionRequested](/previous-versions/windows/apps/dn806030(v=win.10)) イベントの説明をご覧ください。
WebView.UnviewableContentIdentified イベント | 新しい [WebView.UnviewableContentIdentified](/uwp/api/windows.ui.xaml.controls.webview.unviewablecontentidentified) イベントを使うと、WebView が PDF ファイルや Office ドキュメントなどの Web 以外のコンテンツに移動したときに応答することができます。 HTML WebView コントロールについては、[MSWebViewUnviewableContentIdentified](/microsoft-edge/webview) イベントの説明をご覧ください。
WebView.AddWebAllowedObject メソッド | 新しい [WebView.AddWebAllowedObject](/uwp/api/windows.ui.xaml.controls.webview.addweballowedobject) メソッドを呼び出すと、WinRT オブジェクトを XAML WebView に挿入し、その WebView でホストされている信頼された JavaScript から関数を呼び出すことができます。 たとえば、Web コンテンツで、親アプリが [ToastNotificationManager](/uwp/api/windows.ui.notifications.toastnotificationmanager) WinRT API を呼び出すことを要求することで、システム通知を表示することができます。 HTML WebView コントロールについては、[addWebAllowedObject](/microsoft-edge/webview) メソッドの説明をご覧ください。
WebView.ClearTemporaryWebDataAsync メソッド | ユーザーが XAML WebView 内で Web コンテンツを操作すると、ユーザーのセッションに基づいて、WebView コントロールにデータがキャッシュされます。 新しい [ClearTemporaryWebDataAsync](/uwp/api/windows.ui.xaml.controls.webview.cleartemporarywebdataasync) メソッドを呼び出すことで、このキャッシュを消去できます。 たとえば、あるユーザーがアプリからログアウトしたときにキャッシュを消去して、別のユーザーが前のセッションのデータにアクセスできないようにすることができます。
